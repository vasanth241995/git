def release_path
def backup_path
String[] ServerGroup;
def QC_SERVERS
def slct_inv
def superuser
String[] limit

pipeline {

  agent {
    node {
      label "ansible"
    }
  } // ## For SCRUM

  environment {

    dev_servers = 'vlcapdscdevwb1.fisdev.local'

    qc_z1_servers = 'vlcapdscqcz1wb1.fisdev.local,vlcapdscqcz1wb2.fisdev.local'

    qc_z2_servers = 'vlcapdscqcz2wb1.fisdev.local,vlcapdscqcz2wb2.fisdev.local'

  }

  stages {

    stage('Parameters') {
      steps {
        script {
          properties([
            parameters([
              choice(choices: ['SELECT', 'Dev', 'QC_Z1', 'QC_Z2'], description: 'Choose the environment', name: 'Environment'),
              string(defaultValue: '2.4.51', description: 'Enter the deploying JBCS version', name: 'new_jbcs_vrsn', trim: true),
              string(defaultValue: 'https://access.redhat.com/cspdownload/61be88e980fe156eccf7d9ba8e45e57c/63d7e0e7/httpd24-2.4.51/jbcs-httpd24-httpd-2.4.51-RHEL7-x86_64.zip', description: 'Enter the JBCS URL', name: 'JBCS_url', trim: true),
              string(defaultValue: '', description: 'Enter the Change Number', name: 'ChangeNumber', trim: true),
              string(defaultValue: '', description: 'For Rollback: please provide the BUILD NUMBER from which backup was taken, else ignore.', name: 'BuildNumber', trim: true),
              [$class: 'ChoiceParameter',
                choiceType: 'PT_RADIO',
                description: 'Choose what to do ?',
                filterLength: 1, filterable: false,
                name: 'WhatToDo',
                randomName: 'choice-parameter-925984399619400',
                script: [$class: 'GroovyScript',
                  fallbackScript: [
                    classpath: [],
                    oldScript: '',
                    sandbox: true,
                    script: 'return \'nothing to do\''
                  ],
                  script: [classpath: [], oldScript: '', sandbox: true,
                    script: 'return [\'backup\',\'update\',\'rollback\']'
                  ]
                ]
              ],
              [$class: 'ChoiceParameter',
                choiceType: 'PT_RADIO',
                description: 'Which servers to perform the tasks ?',
                filterLength: 1, filterable: false,
                name: 'OutageSelection',
                randomName: 'choice-parameter-925984402316500',
                script: [$class: 'GroovyScript',
                  fallbackScript: [
                    classpath: [],
                    oldScript: '',
                    sandbox: true,
                    script: 'return \'nowhere\''
                  ],
                  script: [classpath: [], oldScript: '', sandbox: true,
                    script: 'return[\'OneAtTime\',\'AllAtOnce\']'
                  ]
                ]
              ],
            ])
          ])
        }
      }
    }

    stage("Definition") {
      steps {
        script {

          release_path = "/appl/SCMSupport/Releases"
          backup_path = "/appl/SCMSupport/Backups"

          if ("${ChangeNumber}" == "") {
            error("Change number is empty. Exiting")
          }

          if ("${WhatToDo}" == "rollback") {
            if ("${BuildNumber}" == "") {
              error("For Rollback, please provide the build number with which proper deployment was done. Exiting!!")
            }
          } else {
            if ("${BuildNumber}" == "") {
              BuildNumber = "${BUILD_NUMBER}"
            }
          }

          if (env.Environment == "Dev") {
            DEV_SERVERS = dev_servers.tokenize(',')
            ServerGroup = DEV_SERVERS
            slct_inv = "dev.ini"
            superuser = "webadmin"
            zone = "dev"
            creds_id = "discovery_webadmin"
            proxy_url = "proxy.fisdev.local:8080"
          } else if (env.Environment == "QC_Z1") {
            QC_Z1_SERVERS = qc_z1_servers.tokenize(',')
            ServerGroup = QC_Z1_SERVERS
            slct_inv = "qc_z1.ini"
            superuser = "webadmin"
            zone = "qc"
            creds_id = "discovery_webadmin"
            proxy_url = "proxy.fisdev.local:8080"
          } else if (env.Environment == "QC_Z2") {
            QC_Z2_SERVERS = qc_z2_servers.tokenize(',')
            ServerGroup = QC_Z2_SERVERS
            slct_inv = "qc_z2.ini"
            superuser = "webadmin"
            zone = "qc"
            creds_id = "discovery_webadmin"
            proxy_url = "proxy.fisdev.local:8080"
          }
        }
      }
    }

    stage("Download & Transfer") {
      steps {
        script {
          if ("${WhatToDo}" == "update") {
            withCredentials([
              sshUserPrivateKey(credentialsId: "${creds_id}", keyFileVariable: 'ssh_key'),
              usernamePassword(credentialsId: 'dsartifactory_id', passwordVariable: 'repopwd', usernameVariable: 'repouser')
            ]) {
              echo "INFO: Downloading JDK and certs from Artifactory"
              sh "wget --auth-no-challenge -q --user=${repouser} --password=${repopwd} ${JBCS_url} -O jbcs_${new_jbcs_vrsn}.zip --no-check-certificate"
              for (server in ServerGroup) {
                echo "INFO: Transferring Artifacts"
                sh "ssh -i ${ssh_key} -q -o StrictHostKeyChecking=no ${superuser}@${server} mkdir -p ${release_path}/${ChangeNumber}/${BUILD_NUMBER}"
                sh "scp -i ${ssh_key} -q jbcs_${new_jbcs_vrsn}.zip ${superuser}@${server}:${release_path}/${ChangeNumber}/${BUILD_NUMBER}"
                sh "ssh -i ${ssh_key} -q -o StrictHostKeyChecking=no ${superuser}@${server} ls ${release_path}/${ChangeNumber}/${BUILD_NUMBER}"
                echo "INFO: Artifacts transferred in ${server}"
              }
            }
          }
        }
      }
    }

    stage("Upgrade") {
      steps {
        script {
          if ("${WhatToDo}" == "backup" || "${WhatToDo}" == "update") {
            echo "INFO: Executing playbook."
            serial_no = ""
            if ("${OutageSelection}" == "OneAtTime") {
              serial_no = "1"
            } else if ("${OutageSelection}" == "AllAtOnce") {
              serial_no = "4"
            }
            ansiColor('xterm') {
              ansiblePlaybook(
                playbook: "JBCSPatching/playbook.yml",
                inventory: "JBCSPatching/scrum/$slct_inv",
                credentialsId: "${creds_id}",
                disableHostKeyChecking: true,
                tags: "${WhatToDo}",
                colorized: true,
                // extras: "-vvv",
                extraVars: [
                  zone: "${zone}",
                  new_jbcs_vrsn: "${new_jbcs_vrsn}",
                  build_no: "${BuildNumber}",
                  change_no: "${ChangeNumber}",
                  serial_no: "${serial_no}"
                ]
              )
            }
          }
        }
      }
    }

    stage("Rollback") {
      steps {
        script {
          if ("${WhatToDo}" == "rollback") {
            echo "INFO: Executing Rollback."
            serial_no = ""
            if ("${OutageSelection}" == "OneAtTime") {
              serial_no = "1"
            } else if ("${OutageSelection}" == "AllAtOnce") {
              serial_no = "4"
            }
            ansiColor('xterm') {
              ansiblePlaybook(
                playbook: "JBCSPatching/playbook.yml",
                inventory: "JBCSPatching/scrum/$slct_inv",
                credentialsId: "${creds_id}",
                disableHostKeyChecking: true,
                tags: "${WhatToDo}",
                // extras: "-vvv",
                extraVars: [
                  zone: "${zone}",
                  new_jbcs_vrsn: "${new_jbcs_vrsn}",
                  build_no: "${BuildNumber}",
                  change_no: "${ChangeNumber}",
                  serial_no: "${serial_no}"
                ]
              )
            }
          }
        }
      }
    }
  }
}
